import csv
import os
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection
import numpy as np

# --- Función para transformar etiquetas ---
def transformar_etiqueta(nombre):
    """
    Si la etiqueta contiene '->', convierte la flecha en '→' y pone en negrita 
    la pose de llegada.
    """
    if '->' in nombre:
        origen, destino = nombre.split('->', 1)
        origen = origen.strip()
        destino = destino.strip()
        # Flecha unicode y destino en negrita LaTeX
        return rf"$_{{{origen} \rightarrow}}$$\mathbf{{{destino}}}$"
    else:
        return nombre

# --- Cargar CSV y validar estructura ---
csv_path = input("Paste the full path of the .csv with the data: ").strip('"')
energy_dictionary = {}
population_dictionary = {}

with open(csv_path, mode="r", encoding="utf8") as archive:
    content = archive.readlines()
    first_line_splitted = [place.strip() for place in content[0].split(",")]

    # Structure checks
    checks = [
        first_line_splitted[0] == "Name",
        "Energy_" in first_line_splitted[1],
        "Energy_Error_" in first_line_splitted[2],
        first_line_splitted[3] == "Relative_Population",
        first_line_splitted[4] == "Relative_Population_Error"
    ]

    if all(checks):
        print("The .csv structure seems to be correct.")
    else:
        raise ValueError("""
        The .csv structure is incorrect. Please ensure the header is exactly:
        "Name,Energy_{units},Energy_Error_{units},Relative_Population,Relative_Population_Error"
        """)

    # Extract and validate units
    units_from_energy = first_line_splitted[1].split("_")[1]
    units_from_energy_error = first_line_splitted[2].split("_")[2]

    if units_from_energy == units_from_energy_error:
        units = units_from_energy
        print(f"Units detected: {units}")
    else:
        raise ValueError("Mismatch between Energy and Energy_Error units. Please fix the header.")

# --- Leer datos y crear diccionarios ---
with open(csv_path, mode="r", encoding="utf-8") as archive:
    reader = csv.DictReader(archive)
    for line in reader:
        energy_dictionary[line["Name"]] = [line[f"Energy_{units}"], line[f"Energy_Error_{units}"]]
        population_dictionary[line["Name"]] = [line["Relative_Population"], line["Relative_Population_Error"]]

# --- Preparar datos para gráficas ---
sorted_names = sorted(energy_dictionary.keys(), key=lambda x: float(energy_dictionary[x][0]))
x = np.arange(len(sorted_names))

energies = [float(energy_dictionary[name][0]) for name in sorted_names]
energy_errors = [float(energy_dictionary[name][1]) for name in sorted_names]
populations = [float(population_dictionary[name][0]) for name in sorted_names]
population_errors = [float(population_dictionary[name][1]) for name in sorted_names]

colors_population = plt.cm.Greens(np.linspace(0.9, 0.3, len(sorted_names)))

# --- Generar etiquetas transformadas ---
x_labels = [transformar_etiqueta(name) for name in sorted_names]

# ### NEW: Función auxiliar para anotar barras ###
def annotate_bars(ax, bars, font_size=10):
    """
    Añade el porcentaje exacto encima de cada barra.
    """
    # Ajustar límite Y para que quepa el texto (15% más que la barra más alta)
    max_height = max([b.get_height() for b in bars]) if bars else 0
    current_ylim = ax.get_ylim()
    ax.set_ylim(current_ylim[0], max(current_ylim[1], max_height * 1.15))
    
    for bar in bars:
        height = bar.get_height()
        # Evitar etiquetar si es 0 o muy cercano a 0 para no ensuciar, o etiquetar siempre
        if height > 0.01: 
            ax.annotate(f'{height:.1f}%',
                        xy=(bar.get_x() + bar.get_width() / 2, height),
                        xytext=(0, 3),  # 3 points vertical offset
                        textcoords="offset points",
                        ha='center', va='bottom',
                        fontsize=font_size, fontweight='bold', color='black')

# ---- 1. Gráfica combinada: dos subplots alineados ----
fig, (ax_energy, ax_pop) = plt.subplots(
    2, 1, figsize=(10, 8), sharex=True, 
    gridspec_kw={'height_ratios': [1, 1.2]}
)

# --- Arriba: Energía ---
points = np.array([x, energies]).T.reshape(-1, 1, 2)
segments = np.concatenate([points[:-1], points[1:]], axis=1)

cmap = plt.get_cmap('Blues_r')
colors = cmap(np.linspace(0.1, 0.7, len(segments)))

lc = LineCollection(segments, colors=colors, linewidth=2, zorder=2)
ax_energy.add_collection(lc)
ax_energy.scatter(x, energies, color='red', zorder=3, label='Energy Points')
ax_energy.errorbar(x, energies, yerr=energy_errors, fmt='none', ecolor='gray', capsize=5, elinewidth=1, zorder=1)

ax_energy.set_ylabel(f"Energy ({units})", fontweight='bold', color='blue', fontsize=18)
ax_energy.tick_params(axis='y', labelcolor='blue', labelsize=18)
ax_energy.grid(False)

# --- Abajo: Población (barras) ---
# ### NEW: Capturamos el objeto 'bars' para anotar ###
bars = ax_pop.bar(x, populations, yerr=population_errors, capsize=5, color=colors_population, edgecolor='black')

# ### NEW: Llamada a la función de anotación ###
annotate_bars(ax_pop, bars, font_size=14)

ax_pop.set_xlabel("QCy(MeBT)₃ conformer", fontweight='bold', fontsize=18)
ax_pop.set_ylabel("Relative Population (%)", fontweight='bold', color='green', fontsize=18)
ax_pop.tick_params(axis='y', labelcolor='green', labelsize=18)
ax_pop.set_xticks(x)

# ### NEW: Ajuste de padding en las etiquetas del eje X ###
ax_pop.set_xticklabels(x_labels, rotation=45, ha='right', fontsize=18)
ax_pop.tick_params(axis='x', which='major', pad=12) # Da más espacio a las etiquetas

ax_pop.grid(False)

# --- Ocultar bordes ---
ax_energy.spines['bottom'].set_visible(False)
ax_pop.spines['top'].set_visible(False)
ax_energy.tick_params(axis='x', which='both', bottom=False, top=False, labelbottom=False)

plt.tight_layout()
plt.savefig("combined_subplot.png", dpi=300)
plt.show()

# ---- 2. Gráficas sueltas ----

# Gráfica solo de poblaciones
fig_pop, ax_single_pop = plt.subplots(figsize=(9, 6)) # Usar subplots es más seguro para manipular ejes
bars_single = ax_single_pop.bar(x, populations, yerr=population_errors, capsize=5, color=colors_population, edgecolor='black')

# ### NEW: Anotar también la gráfica individual ###
annotate_bars(ax_single_pop, bars_single, font_size=12)

ax_single_pop.set_xlabel("QCy(MeBT)₃ conformer", fontweight="bold", fontsize=20)
ax_single_pop.set_ylabel("Relative Population (%)", fontweight="bold", fontsize=20)
ax_single_pop.set_title("Relative Population", fontweight="bold", fontsize=20)
ax_single_pop.set_xticks(x)
ax_single_pop.set_xticklabels(x_labels, rotation=45, ha='right', fontsize=16)
ax_single_pop.tick_params(axis='x', which='major', pad=10)

plt.tight_layout()
plt.savefig("population_plot.png", dpi=300)
plt.show()

# Gráfica solo de energías
fig, ax = plt.subplots(figsize=(9, 6))
ax.add_collection(LineCollection(segments, colors=colors, linewidth=2))
ax.scatter(x, energies, color='red', zorder=3, label='Energy Points')
ax.errorbar(x, energies, yerr=energy_errors, fmt='none', ecolor='gray', capsize=5, elinewidth=1, zorder=2)

ax.set_xticks(x)
ax.set_xticklabels(x_labels, rotation=45, ha='right', fontsize=16)
ax.tick_params(axis='x', which='major', pad=10) # Padding extra

ax.set_xlabel("QCy(MeBT)₃ conformer", fontweight='bold', fontsize=20)
# Corregido pequeño error de string en tu código original ('bold, fontsize...)
ax.set_ylabel(f"Energy ({units})", fontweight='bold', fontsize=20) 
ax.set_title("Energy Comparison", fontweight='bold', fontsize=16)

plt.tight_layout()
plt.savefig("energy_plot.png", dpi=300)
plt.show()
